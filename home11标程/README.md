# 第三次规格程序作业标程与设计说明

## 开始运行

如题：

标准调用方法：

```java
import com.oocourse.specs3.AppRunner;

public class Main {
    public static void main(String[] args) throws Exception {
        AppRunner runner = AppRunner.newInstance(MyPath.class, MyGraph.class);
        runner.run(args);
    }
}

```

即，传入自己实现的Path类和RailwaySystem类即可，系统会自动完成实例化。

## 架构设计


### 设计思考

首先，拿到这个作业，我们可以立刻发现几件事：

* 我们需要对数据（Path）进行最基本的增删查改管理
* 我们需要在数据量较大的情况下，进行最短路的信息的计算

之后，稍作分析，我们可以发现：

* 最短路问题看似很复杂，实际上几个最短路问题所采用的模型基本类似（甚至可以一个模型搞定四个问题）
* 数据量较大，每次都来一次计算并不容易，应当充分利用之前的数据，使得计算过程变得平滑

以及，实际程序编写的时候，我们可以发现：

* 如果所有的逻辑全部堆在`RailwaySystem`的话，那么毫无疑问逻辑会变得很臃肿很杂乱，可维护性极差
* 所以显然架构分层是必须的，无论是出于减少错误的角度，还是处于功能扩展的角度

最终分析可以发现：

* 图结构，是各个问题公用的
* 图缓存计算功能，也是各个问题通用的
* 图的建模形态，虽然略有差异，但是主干逻辑基本通用

于是就可以根据上述的分析结果，进行架构设计。

### 架构层次

#### 基础层

本层次主要是一些基础的类和对象。

* `Node` 表示节点类
* `Edge` 由两个Node组成，表示一条弧
* `Path` 即作业中要求的Path类，表示一条路径

#### 数据结构层

##### 图数据结构

本部分主要用于封装图数据结构（即`GraphCore`）：

* 有向图结构
* 无向图结构

支持图数据结构的各种基本增删查改操作：

* 增加边
* 删除边
* 改变边权
* 基于某一点，遍历出边

其中，无向图只需要在有向图结构上进行一层封装（准确的说，增删改部分重载为正反双重即可）

##### 边集合数据结构

本部分主要用于封装路径集合数据结构（`PathContainer`），支持：

* 增加路径
* 删除路径
* 查询路径

等路径集合基本操作

#### 缓存计算层

本部分使用组合模式，内含一个图数据结构，基于内部的图实现了：

* 图缓存支持
* 最短路计算

两个核心计算功能

#### 图建模层

本部分使用组合模式+工厂模式，内含一个图缓存计算模块，实现了：

* 按照一定的规则，初始化时自动基于给定的数据信息进行图的建模
* 同时直接调用内部的缓存计算模块，进行最短路的计算

#### 应用层

本层即为面向具体应用的设计层：

* `PathContainer` 面向第一次作业（对于第一次作业而言，又是基础数据结构，又是应用结构）
* `Graph` 面向第二次作业（基于第一次的结构，整合图数据结构功能）
* `RailwaySystem` 面向第三次作业（基于第二次图功能，扩展更复杂的图业务）

### 设计思考

* 图数据结构单独封装。**图结构就是图结构，和用来干什么没有任何关系**。简而言之，各个模块功能要明确而纯粹。
* 设计父类的时候，即应该充分考虑未来的扩展性
  * 比如，使用类似Event的机制，在各个关键位置上流出protected方法（addNodeEvent, addEdgeEvent, structureChangeEvent等），留给子类在指定的位置上进行扩展
  * 继承在逻辑扩展上的正确用法之一，是通过protected提供可供@Override的方法（一般设置在各处咽喉要道），以便子类中进行重载，以实现功能扩展。
* 当扩展遇到困难的时候，不要默认之前写过的类就是完全不可以修改的。实际上，通过给整理父类结构，并添加可扩展方法，是很常见也很高效的架构优化方法。
* **不要滥用继承，而是组合代替继承**。
* 实际上，无论是缓存最短路，还是直接floyd，图计算的部分都是可以一样进行抽象的。
* 此架构一个很重要的特性，那就是层和层之间几乎零耦合。**换言之，想对某一层进行优化和修改的话，只需要保持外部方法的性质不变，即可以在很小的一个局部完成整体的优化**。而这个局部之外（上层、下层）的任何地方，则不需要关心这个局部里面到底发生了啥，只在乎其前因和后果即可。

## 说明

* 本程序为标准程序，而且着重于演示设计架构需要，所以
    * 在常数层面，没有优化的很深
    * 在建图方式层面，没有优化的很深
    * 在最短路径算法层面，也没有优化的很深
    * 所以**欢迎大家尝试在这一框架下进行继续优化**（实际性能层面上的优化空间还是很大的）
* 实际上，本程序的扩展非常友好。比如，我们可以很快的实现
    * **为不同的求解问题定制不同的图模型**。只需要用类似其他几个`GraphModelFactory`那样的方式，继承一下`GraphModelFactory`，实现好建图算法，对外提供计算方法，在`RailwaySystem`里面换一个用于实例化的类即可。
    * **进一步扩展新的应用功能**。没错，包括牵扯到图结构维护类的功能！`MyPathContainer`里面留出了相应的protected方法（必要的话还可以再加），只需要在子类中，先调用super然后执行自己的操作即可。
* 实际上，本程序的优化非常方便和友好。因为基于上述的架构设计，我们可以很快的实现
    * **底层常数优化**。比如把`GraphCore`里面的存储模式改改（例如换成静态数组之类的），保持各处方法对外性质不变即可。
    * **建图优化**。比如把`RailwayGraphModelFactory`里面的建图规则改下，并保持`getShortestPath`方法对外性质不变即可。
    * **最短路径优化**。这个更加简单，只需要把`PathCalculationGraphCore`的内部简单重构下，保持各个方法对外性质不变即可。
* 综上所述，无论是那个层面的优化和扩展，实际上都不需要修改哪怕第二个文件。这也正是这样的一个架构的成功之处。